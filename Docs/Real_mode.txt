segmentation memory model
In 8086
CS 
DS
ES
SS

M[Segment:16 + offset] 
code starts with 0x7c00
but in assembly its origin ia 0
how we are going to access it 
code segment = 0x7c0 
offset is 0 for our first instruction 
0x7c0 * 16 = 0x7c00
0x7c00 + offset(0) = 0x7c00

'lodsb' --> uses DS:SI 

How to setup stack segment and stack pointer 
SS segment is at 0 
0x0 ----> stack segment starts 
.
.
.
0x7c00 ---> stack pointer 

and stack operations are done using [SS:SP]
and stack grows downwards by decrementing stack pointer

--------------------------------------------------------------------------------------------------------------------------------

BIOS parameter block 
is a data structure which present at the top of boot sector and tells the BOOTLOADER which file system we are using and 
it should be loacated at 11 bytes from start of boot sector

if BPB is not present it can replace our code with BPB block and cannot be booted in most of devices

to make sure BPB is present we will replace this with Dummy data 


_start:
    jmp short start  3 bytes for this 
    nop
    
times 33 db 0 ;padding for BPB block dummy data avaialable

---------------------------------------------------------------------------------------------------------------------------------
Interrupt Vector Table

Interrupts are like subroutines 
interrupt is called using numbers rather than addresses

IVT present in first 1KB of in memory 

steps of interrupt 
1. processor is interrupted
2. old state saved on the stack 
3. interrupt is Executed 
4. old state is restored

we have 256 interrupts and each interrupt entry is 4 bytes
256 * 4 = 1024 bytes = 1KB 

interrupts are in numerical order 

interrupt 1    | interrupt 2   |
offset segment |offset segment |
0x00    0x7c0    0x8d00  0x00
2bytes  2bytes 

interrupt 0 = address 0x0
interrupt 1 = address 0x04

int 0x13

0x13 * 4 --> address of entry in IVT 
then takes out offset and segment and runs actual address

Implement Our own interrupt

handler_zero: this will replace the first entry

--------------------------------------------------------------------------------------------------------------------------------
Disk access and how it works

1. filesystems are kernel Implemented they are not responsibility of the hard Disk

2. Implemening a filesystem requires the kernel programmer to create a filesystem driver for target filesystem

Data is read and written in sectors
sector size is 512 bytes block 

Reading a sector means disk will return 512 bytes of data for the chsoen sector 

CHS is old way 
LBA 
specify the number LBA 0 returns a first sector

How to calculate LBA 
58376 bytes
LBA = 58376/512 = 114
offset = 58376 % 512 = 8

In 16 bit real mode BIOS provides us 13h for disk operations 
In 32 bit mode creates our very own disk driver which is little more complicated

int 0x13

ah = 02h
al = number of sectors to read 
ch = low eight bits of cylinder number
cl = sector number
dh = head number
dl = drive number (already set by BIOS while loading boot sector)
ES:BX --> data buffer

---------------------------------------------------------------------------------------------------------------------------------

Real mode memory map
Physical Address Range    Size      Description
0x00000000 - 0x000003FF   1 KB      Interrupt Vector Table (IVT)
0x00000400 - 0x000004FF   256 B     BIOS Data Area (BDA)
0x00000500 - 0x00007BFF   ~30 KB    Conventional Memory (free for DOS)
0x00007C00 - 0x00007DFF   512 B     Boot Sector (YOUR BOOTLOADER HERE)
0x00007E00 - 0x0007FFFF   ~480 KB   Conventional Memory (free)
0x00080000 - 0x0009FFFF   128 KB    Extended Conventional Memory
0x000A0000 - 0x000BFFFF   128 KB    Video RAM (VGA memory)
0x000C0000 - 0x000C7FFF   32 KB     Video BIOS
0x000C8000 - 0x000EFFFF   160 KB    ROM Area (various adapters)
0x000F0000 - 0x000FFFFF   64 KB     System BIOS ROM
0x00100000 - 0xFFFFFFFF   ~4GB-1MB  Extended Memory (above 1MB)